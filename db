Download the React DevTools for a better development experience: https://react.dev/link/react-devtools
trainerApi.js:9   PUT http://localhost:9090/api/trainer/tasks/5 400 (Bad Request)
dispatchXhrRequest @ xhr.js:198
xhr @ xhr.js:15
dispatchRequest @ dispatchRequest.js:51
Promise.then
_request @ Axios.js:163
request @ Axios.js:40
httpMethod @ Axios.js:224
wrap @ bind.js:12
updateTask @ trainerApi.js:9
handleSubmit @ UpdateTask.jsx:39
executeDispatch @ react-dom-client.development.js:19116
runWithFiberInDEV @ react-dom-client.development.js:870
processDispatchQueue @ react-dom-client.development.js:19165
(anonymous) @ react-dom-client.development.js:19767
batchedUpdates$1 @ react-dom-client.development.js:3255
dispatchEventForPluginEventSystem @ react-dom-client.development.js:19320
dispatchEvent @ react-dom-client.development.js:23584
dispatchDiscreteEvent @ react-dom-client.development.js:23552
<form>
exports.jsxDEV @ react-jsx-dev-runtime.development.js:327
UpdateTask @ UpdateTask.jsx:52
react_stack_bottom_frame @ react-dom-client.development.js:25904
renderWithHooks @ react-dom-client.development.js:7662
updateFunctionComponent @ react-dom-client.development.js:10166
beginWork @ react-dom-client.development.js:11778
runWithFiberInDEV @ react-dom-client.development.js:870
performUnitOfWork @ react-dom-client.development.js:17639
workLoopConcurrentByScheduler @ react-dom-client.development.js:17634
renderRootConcurrent @ react-dom-client.development.js:17615
performWorkOnRoot @ react-dom-client.development.js:16498
performWorkOnRootViaSchedulerTask @ react-dom-client.development.js:18957
performWorkUntilDeadline @ scheduler.development.js:45
<UpdateTask>
exports.jsxDEV @ react-jsx-dev-runtime.development.js:327
App @ App.js:68
react_stack_bottom_frame @ react-dom-client.development.js:25904
renderWithHooks @ react-dom-client.development.js:7662
updateFunctionComponent @ react-dom-client.development.js:10166
beginWork @ react-dom-client.development.js:11778
runWithFiberInDEV @ react-dom-client.development.js:870
performUnitOfWork @ react-dom-client.development.js:17639
workLoopSync @ react-dom-client.development.js:17469
renderRootSync @ react-dom-client.development.js:17450
performWorkOnRoot @ react-dom-client.development.js:16498
performWorkOnRootViaSchedulerTask @ react-dom-client.development.js:18957
performWorkUntilDeadline @ scheduler.development.js:45
<App>
exports.jsxDEV @ react-jsx-dev-runtime.development.js:327
./src/index.js @ index.js:10
options.factory @ react refresh:37
__webpack_require__ @ bootstrap:22
(anonymous) @ startup:7
(anonymous) @ startup:7
react-dom-client.development.js:6099  Uncaught Error: Objects are not valid as a React child (found: object with keys {userId, trainerId}). If you meant to render a collection of children, use an array instead.
    at throwOnInvalidObjectTypeImpl (react-dom-client.development.js:6099:1)
    at throwOnInvalidObjectType (react-dom-client.development.js:6109:1)
    at reconcileChildFibersImpl (react-dom-client.development.js:7058:1)
    at react-dom-client.development.js:7098:1
    at reconcileChildren (react-dom-client.development.js:9699:1)
    at beginWork (react-dom-client.development.js:11988:1)
    at runWithFiberInDEV (react-dom-client.development.js:870:1)
    at performUnitOfWork (react-dom-client.development.js:17639:1)
    at workLoopSync (react-dom-client.development.js:17469:1)
    at renderRootSync (react-dom-client.development.js:17450:1)
throwOnInvalidObjectTypeImpl @ react-dom-client.development.js:6099
throwOnInvalidObjectType @ react-dom-client.development.js:6109
reconcileChildFibersImpl @ react-dom-client.development.js:7058
(anonymous) @ react-dom-client.development.js:7098
reconcileChildren @ react-dom-client.development.js:9699
beginWork @ react-dom-client.development.js:11988
runWithFiberInDEV @ react-dom-client.development.js:870
performUnitOfWork @ react-dom-client.development.js:17639
workLoopSync @ react-dom-client.development.js:17469
renderRootSync @ react-dom-client.development.js:17450
performWorkOnRoot @ react-dom-client.development.js:16583
performWorkOnRootViaSchedulerTask @ react-dom-client.development.js:18957
performWorkUntilDeadline @ scheduler.development.js:45
<div>
exports.jsxDEV @ react-jsx-dev-runtime.development.js:327
UpdateTask @ UpdateTask.jsx:51
react_stack_bottom_frame @ react-dom-client.development.js:25904
renderWithHooks @ react-dom-client.development.js:7662
updateFunctionComponent @ react-dom-client.development.js:10166
beginWork @ react-dom-client.development.js:11778
runWithFiberInDEV @ react-dom-client.development.js:870
performUnitOfWork @ react-dom-client.development.js:17639
workLoopSync @ react-dom-client.development.js:17469
renderRootSync @ react-dom-client.development.js:17450
performWorkOnRoot @ react-dom-client.development.js:16583
performWorkOnRootViaSchedulerTask @ react-dom-client.development.js:18957
performWorkUntilDeadline @ scheduler.development.js:45
<UpdateTask>
exports.jsxDEV @ react-jsx-dev-runtime.development.js:327
App @ App.js:68
react_stack_bottom_frame @ react-dom-client.development.js:25904
renderWithHooks @ react-dom-client.development.js:7662
updateFunctionComponent @ react-dom-client.development.js:10166
beginWork @ react-dom-client.development.js:11778
runWithFiberInDEV @ react-dom-client.development.js:870
performUnitOfWork @ react-dom-client.development.js:17639
workLoopSync @ react-dom-client.development.js:17469
renderRootSync @ react-dom-client.development.js:17450
performWorkOnRoot @ react-dom-client.development.js:16498
performWorkOnRootViaSchedulerTask @ react-dom-client.development.js:18957
performWorkUntilDeadline @ scheduler.development.js:45
<App>
exports.jsxDEV @ react-jsx-dev-runtime.development.js:327
./src/index.js @ index.js:10
options.factory @ react refresh:37
__webpack_require__ @ bootstrap:22
(anonymous) @ startup:7
(anonymous) @ startup:7
UpdateTask.jsx:51  An error occurred in the <div> component.

Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.


package com.finalproject.internMgmtSystem.controller;

import com.finalproject.internMgmtSystem.dto.AttendanceDto;
import com.finalproject.internMgmtSystem.dto.PerformanceDto;
import com.finalproject.internMgmtSystem.dto.TaskDto;
import com.finalproject.internMgmtSystem.dto.UserBatchDto;
import com.finalproject.internMgmtSystem.model.*;
import com.finalproject.internMgmtSystem.service.TrainerService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/trainer")
@CrossOrigin
public class TrainerController {

    @Autowired
    private TrainerService trainerService;

    // View all batches assigned to trainer
    @GetMapping("/batches/{trainerId}")
    public List<InternshipBatch> getBatches(@PathVariable Long trainerId) {
        return trainerService.getBatches(trainerId);
    }

    // Add Task
    @PostMapping("/tasks")
    public Task addTask(@Valid @RequestBody TaskDto dto) {
        return trainerService.addTask(dto);
    }
    
 // View all tasks assigned by the trainer
    @GetMapping("/tasks/{trainerId}")
    public List<Task> getTasksByTrainerId(@PathVariable Long trainerId) {
        return trainerService.getTasksByTrainerId(trainerId);
    }


    // Update Task
    @PutMapping("/tasks/{taskId}")
    public String updateTask(@Valid @RequestBody TaskDto dto, @PathVariable Long taskId) {
        trainerService.updateTask(dto, taskId);
        return "Task updated successfully";
    }

    // Delete Task
    @DeleteMapping("/tasks/{taskId}")
    public String deleteTask(@PathVariable Long taskId) {
        trainerService.deleteTask(taskId);
        return "Task deleted successfully";
    }

    // Mark Attendance
    @PostMapping("/attendance")
    public Attendance markAttendance(@Valid @RequestBody AttendanceDto dto) {
        return trainerService.markAttendance(dto);
    }

    // Update Performance
    @PostMapping("/performance")
    public Performance updatePerformance(@Valid @RequestBody PerformanceDto dto) {
        return trainerService.updatePerformance(dto);
    }

    // View Feedback
    @GetMapping("/feedback/{trainerName}")
    public List<Feedback> getFeedback(@PathVariable String trainerName) {
        return trainerService.viewFeedback(trainerName);
    }
    
	// View all performance records assigned by the trainer
	@GetMapping("/performance/{trainerId}")
	public List<Performance> getPerformanceByTrainerId(@PathVariable Long trainerId) {
		return trainerService.getPerformanceByTrainerId(trainerId);
	}

  //Fetching the batches and corresponding users
    @GetMapping("/UserBatch/{trainerId}")
    public List<UserBatchDto> getUsersByTrainerId(@PathVariable int trainerId) {
        return trainerService.getUsersByTrainerId(trainerId);
    }
}
package com.finalproject.internMgmtSystem.service;

import com.finalproject.internMgmtSystem.dto.AttendanceDto;
import com.finalproject.internMgmtSystem.dto.PerformanceDto;
import com.finalproject.internMgmtSystem.dto.TaskDto;
import com.finalproject.internMgmtSystem.dto.UserBatchDto;
import com.finalproject.internMgmtSystem.exception.ResourceNotFoundException;
import com.finalproject.internMgmtSystem.model.*;
import com.finalproject.internMgmtSystem.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class TrainerService {

    @Autowired
    private BatchDao batchDao;

    @Autowired
    private TaskDao taskDao;

    @Autowired
    private FeedbackDao feedbackDao;

    @Autowired
    private PerformanceDao performanceDao;

    @Autowired
    private AttendanceDao attendanceDao;
    
    @Autowired
    private UserBatchDao UserBatchDao;

    public List<InternshipBatch> getBatches(Long trainerId) {
        List<InternshipBatch> list = batchDao.findByTrainerId(trainerId);

        if (list.isEmpty()) {
            throw new ResourceNotFoundException("No batches assigned to trainer ID: " + trainerId);
        }

        return list;
    }

    public Task addTask(TaskDto dto) {

        // Optional: validate if user exists / trainer exists

        Task t = new Task();
        t.setUserId(dto.getUserId());
        t.setDescription(dto.getDescription());
        t.setTrainerId(dto.getTrainerId());
        t.setStatus(dto.getStatus());
        t.setDeadline(dto.getDeadline());
        t.setUploadFile(dto.getUploadFile());

        return taskDao.save(t);
    }

    public void updateTask(TaskDto dto, Long taskId) {
        Task t = taskDao.findById(taskId);
        if (t == null) {
            throw new ResourceNotFoundException("Task not found with ID: " + taskId);
        }

        t.setDescription(dto.getDescription());
        t.setStatus(dto.getStatus());
        t.setDeadline(dto.getDeadline());
        t.setUploadFile(dto.getUploadFile());

        taskDao.update(t);
    }

    public void deleteTask(Long id) {
        Task exists = taskDao.findById(id);
        if (exists == null) {
            throw new ResourceNotFoundException("Task not found with ID: " + id);
        }

        taskDao.delete(id);
    }

    public Attendance markAttendance(AttendanceDto dto) {

        if (dto.getDate().toLocalDate().isAfter(LocalDate.now())) {
            throw new RuntimeException("Cannot mark attendance for future dates");
        }

        Attendance a = new Attendance();
        a.setUserId(dto.getUserId());
        a.setBatchCode(dto.getBatchCode());
        a.setDate(dto.getDate());
        a.setPresent(dto.getPresent());

        return attendanceDao.save(a);
    }

    public Performance updatePerformance(PerformanceDto dto) {

        Performance p = new Performance();

        p.setUserId(dto.getUserId());
        p.setTrainerId(dto.getTrainerId());
        p.setBatchCode(dto.getBatchCode());       // NEW
        p.setTrainerName(dto.getTrainerName());   // NEW
        p.setRemarks(dto.getRemarks());
        p.setTaskEvaluationScore(dto.getTaskEvaluationScore());

        return performanceDao.save(p);
    }


    public List<Feedback> viewFeedback(String trainerName) {
        List<Feedback> list = feedbackDao.findByTrainerName(trainerName);

        if (list.isEmpty()) {
            throw new ResourceNotFoundException("No feedback found for trainer: " + trainerName);
        }

        return list;
    }
    
    public List<UserBatchDto> getUsersByTrainerId(int trainerId) {
        return UserBatchDao.getUsersByTrainerId(trainerId);
    }
    public List<Task> getTasksByTrainerId(Long trainerId) {
        List<Task> tasks = taskDao.findByTrainerId(trainerId);
        if (tasks.isEmpty()) {
            throw new ResourceNotFoundException("No tasks found for trainer ID: " + trainerId);
        }
        return tasks;
    }

    public List<Performance> getPerformanceByTrainerId(Long trainerId) {
        List<Performance> list = performanceDao.findByTrainerId(trainerId);
        if (list.isEmpty()) {
            throw new ResourceNotFoundException("No performance records found for trainer ID: " + trainerId);
        }
        return list;
    }

}
package com.finalproject.internMgmtSystem.repository;

import com.finalproject.internMgmtSystem.model.Task;
import com.finalproject.internMgmtSystem.repository.TaskDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class TaskDaoImpl implements TaskDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private RowMapper<Task> mapper = (rs, rowNum) -> {
        Task t = new Task();
        t.setId(rs.getLong("id"));
        t.setUserId(rs.getLong("user_id"));
        t.setDescription(rs.getString("description"));
        t.setTrainerId(rs.getLong("trainer_id"));
        t.setStatus(rs.getString("status"));
        t.setDeadline(rs.getDate("deadline"));
        t.setUploadFile(rs.getString("upload_file"));
        t.setCreatedAt(rs.getTimestamp("created_at"));
        return t;
    };

    @Override
    public Task save(Task task) {
        String sql = """
            INSERT INTO tasks (user_id, description, trainer_id, status, deadline, upload_file)
            VALUES (?, ?, ?, ?, ?, ?)
        """;

        jdbcTemplate.update(sql,
                task.getUserId(),
                task.getDescription(),
                task.getTrainerId(),
                task.getStatus(),
                task.getDeadline(),
                task.getUploadFile()
        );

        Long id = jdbcTemplate.queryForObject("SELECT LAST_INSERT_ID()", Long.class);
        task.setId(id);
        return task;
    }

    @Override
    public Task findById(Long id) {
        List<Task> list = jdbcTemplate.query(
                "SELECT * FROM tasks WHERE id = ?",
                mapper,
                id
        );
        return list.isEmpty() ? null : list.get(0);
    }

    @Override
    public List<Task> findByUserId(Long userId) {
        return jdbcTemplate.query(
                "SELECT * FROM tasks WHERE user_id = ? ORDER BY created_at DESC",
                mapper,
                userId
        );
    }

    @Override
    public List<Task> findByTrainerId(Long trainerId) {
        return jdbcTemplate.query(
                "SELECT * FROM tasks WHERE trainer_id = ? ORDER BY created_at DESC",
                mapper,
                trainerId
        );
    }

    @Override
    public void update(Task task) {
        String sql = """
            UPDATE tasks SET description=?, status=?, deadline=?, upload_file=? WHERE id=?
        """;

        jdbcTemplate.update(sql,
                task.getDescription(),
                task.getStatus(),
                task.getDeadline(),
                task.getUploadFile(),
                task.getId()
        );
    }

    @Override
    public void delete(Long id) {
        jdbcTemplate.update("DELETE FROM tasks WHERE id = ?", id);
    }
}
package com.finalproject.internMgmtSystem.repository;

import com.finalproject.internMgmtSystem.model.Task;
import java.util.List;

public interface TaskDao {

    Task save(Task task);

    Task findById(Long id);

    List<Task> findByUserId(Long userId);

    List<Task> findByTrainerId(Long trainerId);

    void update(Task task);

    void delete(Long id);
}
package com.finalproject.internMgmtSystem.repository;

import com.finalproject.internMgmtSystem.model.Trainer;
import java.util.List;

public interface TrainerDao {

    Trainer save(Trainer trainer);

    Trainer findByEmail(String email);

    Trainer findById(Long id);

    List<Trainer> findAll();

    void update(Trainer trainer);

    void deleteById(Long id);

    void deleteByEmail(String email);
}
package com.finalproject.internMgmtSystem.repository;

import com.finalproject.internMgmtSystem.model.Trainer;
import com.finalproject.internMgmtSystem.repository.TrainerDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class TrainerDaoImpl implements TrainerDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private RowMapper<Trainer> mapper = (rs, rowNum) -> {
        Trainer t = new Trainer();
        t.setTrainerId(rs.getLong("trainer_id"));
        t.setName(rs.getString("name"));
        t.setEmail(rs.getString("email"));
        t.setPassword(rs.getString("password"));
        t.setContact(rs.getString("contact"));
        t.setExperience(rs.getString("experience"));
        t.setSkills(rs.getString("skills"));
        t.setProfilePic(rs.getString("profile_pic"));
        t.setBio(rs.getString("bio"));
        t.setRole(rs.getString("role"));
        t.setCreatedAt(rs.getTimestamp("created_at"));
        return t;
    };

    @Override
    public Trainer save(Trainer trainer) {
        String sql = "INSERT INTO trainers (name, email, password, contact, experience, skills, profile_pic, bio, role) "
                   + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";

        jdbcTemplate.update(sql,
                trainer.getName(),
                trainer.getEmail(),
                trainer.getPassword(),
                trainer.getContact(),
                trainer.getExperience(),
                trainer.getSkills(),
                trainer.getProfilePic(),
                trainer.getBio(),
                trainer.getRole()
        );

        Long id = jdbcTemplate.queryForObject("SELECT LAST_INSERT_ID()", Long.class);
        trainer.setTrainerId(id);
        return trainer;
    }

    @Override
    public Trainer findByEmail(String email) {
        List<Trainer> list = jdbcTemplate.query(
                "SELECT * FROM trainers WHERE email = ?",
                mapper,
                email
        );
        return list.isEmpty() ? null : list.get(0);
    }

    @Override
    public Trainer findById(Long id) {
        List<Trainer> list = jdbcTemplate.query(
                "SELECT * FROM trainers WHERE trainer_id = ?",
                mapper,
                id
        );
        return list.isEmpty() ? null : list.get(0);
    }

    @Override
    public List<Trainer> findAll() {
        return jdbcTemplate.query(
                "SELECT * FROM trainers",
                mapper
        );
    }

    @Override
    public void update(Trainer trainer) {
        String sql = "UPDATE trainers SET name=?, contact=?, experience=?, skills=?, profile_pic=?, bio=? "
                   + "WHERE trainer_id=?";

        jdbcTemplate.update(sql,
                trainer.getName(),
                trainer.getContact(),
                trainer.getExperience(),
                trainer.getSkills(),
                trainer.getProfilePic(),
                trainer.getBio(),
                trainer.getTrainerId()
        );
    }

    @Override
    public void deleteById(Long id) {
        jdbcTemplate.update(
                "DELETE FROM trainers WHERE trainer_id = ?",
                id
        );
    }

    @Override
    public void deleteByEmail(String email) {
        jdbcTemplate.update("DELETE FROM trainers WHERE email = ?", email);
    }
}

package com.finalproject.internMgmtSystem.dto;

import jakarta.validation.constraints.*;
import java.sql.Date;

public class TaskDto {

	@NotNull(message = "User ID is required")
	private Long userId;

	@NotBlank(message = "Task description is required")
	private String description;

	@NotNull(message = "Trainer ID is required")
	private Long trainerId;

	@NotBlank(message = "Status is required")
	private String status;

	@NotNull(message = "Deadline is required")
	private Date deadline;

	private String uploadFile;

	public TaskDto() {
	}

	public TaskDto(@NotNull(message = "User ID is required") Long userId,
			@NotBlank(message = "Task description is required") String description,
			@NotNull(message = "Trainer ID is required") Long trainerId,
			@NotBlank(message = "Status is required") String status,
			@NotNull(message = "Deadline is required") Date deadline, String uploadFile) {
		super();
		this.userId = userId;
		this.description = description;
		this.trainerId = trainerId;
		this.status = status;
		this.deadline = deadline;
		this.uploadFile = uploadFile;
	}

	public Long getUserId() {
		return userId;
	}

	public void setUserId(Long userId) {
		this.userId = userId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Long getTrainerId() {
		return trainerId;
	}

	public void setTrainerId(Long trainerId) {
		this.trainerId = trainerId;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public Date getDeadline() {
		return deadline;
	}

	public void setDeadline(Date deadline) {
		this.deadline = deadline;
	}

	public String getUploadFile() {
		return uploadFile;
	}

	public void setUploadFile(String uploadFile) {
		this.uploadFile = uploadFile;
	}

	// getters & setters
}


package com.finalproject.internMgmtSystem.security;

import com.finalproject.internMgmtSystem.model.Trainer;
import com.finalproject.internMgmtSystem.model.User;
import com.finalproject.internMgmtSystem.repository.TrainerDao;
import com.finalproject.internMgmtSystem.repository.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserDao userDao;

    @Autowired
    private TrainerDao trainerDao;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {

        User user = userDao.findByEmail(email);
        if (user != null) {
            return new org.springframework.security.core.userdetails.User(
                    user.getEmail(),
                    user.getPassword(),
                    List.of(new SimpleGrantedAuthority("ROLE_" + user.getRole()))   // FIXED
            );
        }

        Trainer trainer = trainerDao.findByEmail(email);
        if (trainer != null) {
            return new org.springframework.security.core.userdetails.User(
                    trainer.getEmail(),
                    trainer.getPassword(),
                    List.of(new SimpleGrantedAuthority("ROLE_" + trainer.getRole())) // FIXED
            );
        }

        throw new UsernameNotFoundException("User not found: " + email);
    }
}


package com.finalproject.internMgmtSystem.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        final String header = request.getHeader("Authorization");

        if (header == null || !header.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = header.substring(7);

        if (!jwtUtil.isTokenValid(token)) {
            filterChain.doFilter(request, response);
            return;
        }

        Long userId = jwtUtil.extractUserId(token); // â¬… NEW
        String role = jwtUtil.extractRole(token);

        SimpleGrantedAuthority authority = new SimpleGrantedAuthority(role);

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userId, null, List.of(authority)
                );

        SecurityContextHolder.getContext().setAuthentication(authentication);

        filterChain.doFilter(request, response);
    }
}


package com.finalproject.internMgmtSystem.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtil {

    private final long EXPIRATION_TIME = 1000 * 60 * 60 * 10;
    private final Key secretKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    // USER TOKEN
    public String generateToken(Long userId, String email, String role) {
        return Jwts.builder()
                .setSubject(email)
                .claim("userId", userId)
                .claim("role", role)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(secretKey)
                .compact();
    }

    // TRAINER TOKEN (Trainer Name + Trainer ID added)
    public String generateTrainerToken(Long trainerId, String email, String role, String trainerName) {
        return Jwts.builder()
                .setSubject(email)
                .claim("userId", trainerId)    // REQUIRED BY SPRING SECURITY
                .claim("trainerId", trainerId)
                .claim("trainerName", trainerName)
                .claim("role", role)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(secretKey)
                .compact();
    }

    public String extractEmail(String token) {
        return extractAllClaims(token).getSubject();
    }

    public String extractRole(String token) {
        return extractAllClaims(token).get("role", String.class);
    }

    public Long extractUserId(String token) {
        return extractAllClaims(token).get("userId", Long.class);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenValid(String token) {
        try {
            extractAllClaims(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}


package com.finalproject.internMgmtSystem.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.cors.CorsConfigurationSource;

import java.util.List;

@Configuration
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http.csrf(csrf -> csrf.disable());

        // VERY IMPORTANT: enable CORS here
        http.cors(cors -> cors.configurationSource(corsConfigurationSource()));

        http.authorizeHttpRequests(auth -> auth
                .requestMatchers(
                        "/api/auth/login",
                        "/api/user/register"
                ).permitAll()
                .requestMatchers("/api/admin/**").hasAuthority("ROLE_ADMIN")
                .requestMatchers("/api/trainer/**").hasAuthority("ROLE_TRAINER")
                .requestMatchers("/api/user/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
        );

        http.sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        );

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    // FULL CORS CONFIGURATION FOR SPRING SECURITY
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {

        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("http://localhost:3000"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setExposedHeaders(List.of("Authorization"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);

        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
